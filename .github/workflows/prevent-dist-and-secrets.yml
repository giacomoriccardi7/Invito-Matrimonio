name: Prevent dist and secrets

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fail if dist directory is committed
        run: |
          if [ -d "dist" ]; then
            echo "dist/ presente nel commit: vietato."
            exit 1
          fi

      - name: Scan for secrets patterns
        run: |
          set -e
          files_to_scan="src public index.html .github"
          # Pattern pi√π restrittivo: rileva solo assegnazioni con valori letterali lunghi
          patterns='(:|=)\s*["\'`]?([A-Za-z0-9+/]{24,}|[A-Za-z0-9]{32,})'
          # Riferimenti sicuri a variabili d'ambiente da non considerare
          safe_refs='(import\.meta\.env|process\.env)'
          echo "Scanning for sensitive patterns..."
          matches=$(grep -REni --exclude-dir=node_modules --exclude-dir=.git --exclude=*.example "$patterns" $files_to_scan || true)
          unsafe_refs=$(echo "$matches" | grep -v -Ei "$safe_refs" || true)
          # Consider suspicious only if an assignment/colon and a long literal value appear on the same line.
          literal_secret=$unsafe_refs
          if [ -n "$literal_secret" ]; then
            echo "Possibili segreti letterali trovati nel codice:"
            echo "$literal_secret"
            exit 1
          else
            echo "Nessun segreto letterale rilevato (riferimenti env sicuri o nessuna corrispondenza)."
          fi

      - name: Ensure .env files are not present
        run: |
          set -e
          forbidden=$(git ls-files | grep -E '^\.env(\..*)?$|^server/\.env(\..*)?$' || true)
          if [ -n "$forbidden" ]; then
            echo "File .env committati:"
            echo "$forbidden"
            exit 1
          fi